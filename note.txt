一. 计算机启动流程
 1.一般计算机启动流程
                BIOS    ==>    引导程序    ==>    操作系统
  BIOS是系统启动时运行的第一个程序. 主要负责硬件自检和初始化, 中断处理函数的基本设置, 以及从存储器中加载零道零扇区的代码到内存并从当前位置开始运行.而存储在零道零扇区的代码, 通常就是所谓的引导程序.
  引导程序就是用来引导操作系统的. 引导程序的意义是将操作系统从外部存储搬运到内存之中并交出CPU控制权. 引导程序的作用是为被引导的操作系统运行提供运行时需要的环境和条件, 然后将真正的操作系统从外存加载到内存中运行.

 2.嵌入式平台
                引导程序    ==>    操作系统
  通常引导程序会固化到Flash或ROM中, 当系统上电时会首先被运行,起到初始化基本硬件和引导操作系统的双重作用.


二. 操作系统启动流程
1.ARM启动流程
  CPU上电后, ARM会从地址零处开始运行.操作系统启动时至少要注意以下两个方面: 
程序运行栈的初始化: 程序运行时所需的临时变量,数据和函数间调用的参数传递等都需要栈的支持;
处理器及外设的初始化:一个操作系统的能够正常运行,处理器的正确配置和外设的正常工作也是必不可少的先决条件.

2.ARM工作模式
  ARM v6体系及其之前定义了7种工作模式: 管理模式(SVC),快速中断模式(FIQ),中断模式(IRQ),未定义模式(UND),终止模式(ABT),用户模式(USER),系统模式(SYS). 其中前5种为异常模式. 每种异常模式都有自己私有的堆栈指针寄存器R13, 返回地址寄存器R14以及模式备份寄存器SPSR. 一段代码只有处在该异常模式下才有权力访问该异常模式的3个私有寄存器. 当异常发生时, CPU会停止运行当前代码, 转而去运行该异常的预先指定的代码,同时,系统会切换到特定模式, 这种切换方法是被动的. 还有一种切换方法是程序员更改CPSR寄存器中的模式位,切换到指定模式.

3.ARM 跳转指令
  b, bl, bx : 优点是速度快, 只占用一个指令周期时间; 缺点是不能实现任意地址的跳转(前后32M)
  ldr : 优点是能实现任意地址的跳转; 缺点是因为要读写存储器,速度慢一点
  mov : 通过mov指令将寄存器里的地址值传送给程序计数器PC,可以实现跳转,多用于函数返回时的跳转

三.MMU
1.一级查表
  一级查表只支持1M大小的页, 1M大小的页应称为段(section), 因此, 一级页表也称为段页表.
  段页表项的结构:
        31 ~ 20  19 ~ 12  11 ~ 10  9  8 ~ 5  4  3  2  1  0 
         基地址      0      AP     0    域   1  C  B  1  0
  31~20位段表示物理地址的基地址, 段页表项后20位正好可以描述1M大小的内存.段页表最多支持1024项,最多占用4K字节系统空间来存放页表项.
  11~10位是AP位, 区分了用户模式和特权模式对同一个页的访问权限:'11'表示任何模式都可以读写该页;'10'表示特权模式可读写,用户模式只读.
  8~5位代表该页所属的域.在ARM体系结构中规定只有16个域, 因此用4个位足以表示该页属于哪个域, 每个域都有各自的访问权限, 从而实现了对存储器的初级保护.
  3位和2位表示cache和wirte buffer, 相应位为1表示启用.
  1~0位用来区分页表类. 段页表为"10".

2.段表页的地址映射过程
  首先, MMU取出虚拟地址的前12位作为页表项的偏移, 结合页表项基地址, 找到对应的页表项.具体做法是: 取出12位数, 然后左移2位, 与页表项基地址相与, 得到页表项地址.例如页表基地址为0x30000000, 虚拟地址为0x00100c12, 去虚拟地址前12位得0x001, 左移两位得0x004, 与页表基地址相与得0x30000004, 从该地址读取的32位数据就是该虚拟地址的页表项.
  然后, 根据页表项得到物理地址信息: 页表项前12位为物理地址基地址. 因此可以确定物理地址处于哪个地址范围. 例如, 从0x30000004地址读取的数据为0x30000c12, 那么可以确定物理地址的范围为0x30000000~0x30001000.
  接着, MMU将页表项后20位清除, 再与虚拟地址后20位相与, 就得到该虚拟地址对应的物理地址了. 例如页表项内容为0x30000c12, 清除后20位得0x30000000, 虚拟地址后20位为0x01200, 相与的0x30001200, 这便是最终的物理地址.
  MMU在进行地址映射期间还会进行权限检查, 读取页表项的相应位, 检测是否可以访问, 若不允许方位则抛出异常, 供程序捕捉处理.

3.GNU内联汇编
  格式:
    asm(
        语句域
        : 输出运算符列表
        : 输入运算符列表
        : 改变资源列表
    );
  例:
    asm(
        "mov r0, %0\n"
        "mov %0, #0\n"
        :
        : "+r"(val)
        : "r0"
    );
    "r0"表示r0寄存器的值会被改变;
    "+r"表示val(%0)可读写, =r表示可写, &r表示只作输出, r无修饰表示只读. 除了r操作符还有:
        m: 一个有效内存地址
        l: 数据处理指令中的立即数
        X: 只能作为输出

四. 中断
1.寄存器
  通用寄存器: 
  R0~R12: 存储普通数据
  R13(sp): 栈寄存器
    异常发生或程序跳转时,保存通用寄存器数据到sp的内存地址;sp是专用的,不能他用
  R14(lr): 链接寄存器
    当程序发生跳转时用来保存返回地址
  R15(pc): 程序计数器
    读:读出来的数据,是当前正在执行的程序地址+8
    写:cpu会跳转到写入的地址处执行代码

  功能寄存器:
  CPSR: 当前的程序状态寄存器
    N(31位)符号表示位:	1表示结果为负.0表示结果为正.
    Z(30位)零值表示:	1表示结果为0, 0表示结果非0
    C(29位)进位标志: 	1表示存在进位,1表示不存借位,0表示没有进位,存在借位	
    V(28位)溢出标志:	1表示存在溢出,0表示没有溢出
    J(24位)和T(5位):	共同决定工作状态 00表示arm状态
    E(9位):				大小端选择位:0小端 1大端
    I(7位):				irq中断mask位  0为cpu可以中断,1为cpu不中断
    F(6位):				fiq中断mask位  0为cpu可以中断,1为cpu不中断
    M[4:0]:模式选择位:
        when '10000' result = usr; // User mode
        when '10001' result = fiq; // FIQ mode
        when '10010' result = irq; // IRQ mode
        when '10011' result = svc; // Supervisor mode
        when '10110' result = mon; // Monitor mode
        when '10111' result = abt; // Abort mode
        when '11010' result = hyp; // Hyp mode
        when '11011' result = und; // Undefined mode
        when '11111' result = usr; // System mode uses User mode registers

  SPSR: 保存的程序状态寄存器
    当异常发生,进行模式切换时,用来保存cpsr,保存的过程arm自动完成

2.arm的工作模式:
非特权: 
    usr(用户模式)       所有的应用程序的工作模式,不能主动进行模式切换
特权:   
    sys(系统模式)       系统运行的工作模式(linux没有)
  非异常:	
    svc(管理模式)       cpu上电复位之后所处的工作模式.软件中断所处的工作模式
  异常:	
    undef(未定义)       cpu执行代码期间发现一条未定义的指令的工作模式   
    abort(终止模式)     cpu运行期间数据加载失败所处工作模式
    irq (中断模式)      中断的工作模式
    fiq (快速中断)      快速中断的工作模式

cortex-a9增加的模式
    Monitor             安全模式
    Hyp                 支持虚拟化

每一个模式都有一组寄存器
工作模式切换的方法:
  可以修改cpsr的低5位来实现arm工作模式的切换,在usr模式不能实现
  异常都可实现模式切换

3.arm的异常处理:
    arm的异常处理使用异常向量表(异常事件处理方法集合),异常向量可以存放在两个内存地址:
高位0xffff0000,低位0x00000000.当异常发生时硬件会自动跳转到异常向量表处执行.
